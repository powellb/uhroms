#include "cppdefs.h"
      MODULE extract_transport_mod
#if (defined FOUR_DVAR || defined VERIFICATION) && defined OBSERVATIONS
!
!svn $Id: extract_transport.F
!================================================== Brian S. Powell ====
!  Copyright (c) 2002-2019 The ROMS/TOMS Group                         !
!    Licensed under a MIT/X style license                              !
!    See License_ROMS.txt                                              !
!=======================================================================
!                                                                      !
!   This module extracts the paths of transport obs and calculates     !
!   the total transport for each path. Transport can use the           !
!   barotropic velocity (isTransport2d) or the baroclinic velocity     !
!   (isTransport3d).                                                   !
!                                                                      !
!   For a transport observation, it is of the appropriate type,        !
!   specifies:                                                         !
!                                                                      !
!       obs_time       : time of the transport measurement             !
!       obs_value      : the transport measurement in Sverdrups        !
!       obs_type       : either isTransport2d or isTransport3d         !
!       obs_provenance : user selectable                               !
!       obs_meta       : the path ID that describes the plane through  !
!                        which the transport is calculated             !
!                                                                      !
!   The path is stored as a series of points (dimension path), all     !
!   sharing the same ID so they are kept together. Each path point     !
!   represents a surface that the transport is passing through and     !
!   must have the following information:                               !
!                                                                      !
!       path_id     : the ID of the path that this point belongs to    !
!       path_Xgrid  : the fractional i-location of the model grid      !
!                     for this path point                              !
!       path_Ygrid  : the fractional j-location of the model grid      !
!                     for this path point                              !
# ifdef SOLVE3D
!       path_Zgrid  : the fractional k-location of the model grid      !
!                     for this path point if it is a 3D transport      !
!                 NOTE: the height of the cell is calculated for the   !
!                       location provided, so over a single path,      !
!                       each path point should be a full k-value       !
!                       apart from the others; otherwise, there will   !
!                       be "double-counting" as the grid hz values     !
!                       will overlap.                                  !
# endif
!       path_length : the horizontal distance in meters that of this   !
!                     portion of the path                              !
!       path_angle  : the angle in radians of the orientation of this  !   
!                     path relative to the grid (i.e., positive right  !
!                     along the xi-direction is 0 radians).            !
!                                                                      !
!   Multiple paths are allowed, but must have an independent path_ID.  !
!                                                                      !
!   An example of a full-column transport observation across 3         !
!   diagonal points in a 1km resolution grid:                          !
!     obs_time(i)       = 20.33                                        !
!     obs_type(i)       = isTransport2D                                !
!     obs_provenance(i) = 552                                          !
!     obs_value(i)      = 12.34  [Sv]                                  !
!     obs_meta(i)       = 15                                           !
!                                                                      !
!     NOTE: the location is not needed for the transport value because !
!     the values are located in the path; however, for analysis use,   !
!     it may be preferable to specify the lat/lon of the center.       !
!                                                                      !
!   The path, 15, must be defined:                                     !
!     path_ID(1:3)     = 15, 15, 15                                    !
!     path_Xgrid(1:3)  = 10, 11, 12                                    !
!     path_Ygrid(1:3)  = 26, 27, 28                                    !
!     path_length(1:3) = 1414, 1414, 1414     [m]                      !
!     path_angle(1:3)  = 0.7854, 0.7854, 0.7854 [radians]              !
!                                                                      !
!   This will then extract the appropriate velocity at each point      !
!   along with the height (full-column for 2D or cell height for 3D)   !
!   and compute:                                                       !
!     transport = SUM_i [( u_i * sin(path_angle_i) +                   !
!                          v_i * cos(path_angle_i) ) *                 !
!                        path_length(i) * height(i)]                   !
!=======================================================================
!
      USE mod_kinds

      implicit none

      PUBLIC extract_transport_2d
# ifdef SOLVE3D
      PUBLIC extract_transport_3d
# endif

      CONTAINS
!
!***********************************************************************
      SUBROUTINE extract_transport_2d (ng, Imin, Imax, Jmin, Jmax,      &
     &                          LBi, UBi, LBj, UBj,                     &
     &                          Mstr, Mend, Kout,                       &
     &                          Xmin, Xmax, Ymin, Ymax, Aobs)
!***********************************************************************
!
      USE mod_fourdvar
      USE mod_grid
      USE mod_ncparam
      USE mod_ocean
      USE mod_parallel
      USE mod_scalars
# ifdef DISTRIBUTE
      USE distribute_mod,  ONLY :  mp_collect
# endif
      USE extract_obs_mod, ONLY : extract_obs2d
!
!  Imported variable declarations.
!
      integer, intent(in) :: ng, Imin, Imax, Jmin, Jmax
      integer, intent(in) :: LBi, UBi, LBj, UBj
      integer, intent(in) :: Mstr, Mend, Kout
!
      real(r8), intent(in) :: Xmin, Xmax, Ymin, Ymax
!
#  ifdef ASSUMED_SHAPE
      real(r8), intent(inout) :: Aobs(:)
#  else
      real(r8), intent(inout) :: Aobs(Mobs)
#  endif
!
!  Local variable declarations.
!
      integer :: ic, iobs, Rstr, Rend, Robs, Ncollect
      real(dp) :: TimeLB, TimeUB

      real(r8), parameter :: IniVal = 0.0_r8, Sv=1.0e-6_r8

      integer, allocatable, dimension(:) :: path_type
      real(r8), allocatable, dimension(:) :: path_time, path_h
      real(r8), allocatable, dimension(:) :: path_vetting
      real(r8), allocatable, dimension(:) :: path_ubar, path_vbar
      real(r8) :: transport
# ifdef BGQC
      real(r8), allocatable, dimension(:) :: ubarBgErr, vbarBgErr
# endif

!
!  Find the transport path observations that are available
!  for the current time.
!
      TimeLB=(time(ng)-0.5_dp*dt(ng))/86400.0_dp
      TimeUB=(time(ng)+0.5_dp*dt(ng))/86400.0_dp

      OBS_THREAD : DO iobs=Mstr,Mend
        OBS_TYPE : IF ((ObsType(iobs).eq.                               &
     &                  ObsState2Type(isTransport2d)).and.              &
     &      ((TimeLB.le.Tobs(iobs)).and.(Tobs(iobs).lt.TimeUB))) THEN

!
!  Find the transport path points for this transport observation
!
          Rend=0
          Rstr=99999999
          DO ic=1,Npath(ng)
            IF (PathID(ic).eq.ObsMeta(iobs)) THEN
              Rstr=MIN(Rstr,ic)
              Rend=MAX(Rend,ic)
            END IF
          END DO
          Robs=Rend-Rstr+1
          IF (Rstr.gt.Rend) THEN
            ObsVetting(iobs)=0.0_r8
            CYCLE
          END IF

!
!  Allocate the arrays of the transport path data
!
          allocate ( path_time(Robs) )
          path_time=Tobs(iobs)

          allocate ( path_type(Robs) )
          path_type=ObsState2Type(isTransport2d)

          allocate ( path_vetting(Robs) )
          path_vetting=IniVal

          allocate ( path_ubar(Robs) )
          path_ubar=IniVal

          allocate ( path_vbar(Robs) )
          path_vbar=IniVal

          allocate ( path_h(Robs) )
          path_h=IniVal

# ifdef BGQC
          allocate ( ubarBgErr(Robs) )
          ubarBgErr=IniVal

          allocate ( vbarBgErr(Robs) )
          vbarBgErr=IniVal
# endif

!
!  Get the ubar-component for transport calculations.
!
          CALL extract_obs2d (ng, 1, Lm(ng)+1, 0, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj,                       &
     &                        ObsState2Type(isTransport2d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng)+0.5_r8,                         &
     &                        uXmax(ng)+0.5_r8,                         &
     &                        uYmin(ng), uYmax(ng),                     &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend)+0.5_r8,                  &
     &                        PathY(Rstr:Rend),                         & 
     &                        OCEAN(ng)%ubar(:,:,Kout),                 &
#   ifdef MASKING
     &                        GRID(ng)%umask,                           &
#   endif
     &                        path_ubar)
#   ifdef BGQC
          CALL extract_obs2d (ng, 1, Lm(ng)+1, 0, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj,                       &
     &                        ObsState2Type(isTransport2d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng)+0.5_r8, rXmax(ng)+0.5_r8,       &
     &                        uYmin(ng), uYmax(ng),                     &
     &                        time(ng), dt(ng),                         &
     &                        path_type, path_vetting,                  &
     &                        path_time, PathX(Rstr:Rend)+0.5_r8,       &
     &                        PathY(Rstr:Rend),                         &
     &                        OCEAN(ng)%e_ubar(:,:,1),                  &
#    ifdef MASKING
     &                        GRID(ng)%umask,                           &
#    endif
     &                        ubarBgErr)
#   endif

!
!  Get the vbar-component for transport calculations.
!
          CALL extract_obs2d (ng, 0, Lm(ng)+1, 1, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj,                       &
     &                        ObsState2Type(isTransport2d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng), uXmax(ng),                     &
     &                        uYmin(ng)+0.5_r8,                         &
     &                        uYmax(ng)+0.5_r8,                         &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend),                         &
     &                        PathY(Rstr:Rend)+0.5_r8,                  &
     &                        OCEAN(ng)%vbar(:,:,Kout),                 &
#   ifdef MASKING
     &                        GRID(ng)%vmask,                           &
#   endif
     &                        path_vbar)
#   ifdef BGQC
          CALL extract_obs2d (ng, 0, Lm(ng)+1, 1, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj,                       &
     &                        ObsState2Type(isTransport2d),             &
     &                        Robs, Rstr, Rend,                         &
     &                        uXmin(ng), uXmax(ng),                     &
     &                        uYmin(ng)+0.5_r8,                         &
     &                        uYmax(ng)+0.5_r8,                         &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend),                         &
     &                        PathY(Rstr:Rend)+0.5_r8,                  &
     &                        OCEAN(ng)%e_vbar(:,:,1),                  &
#   ifdef MASKING
     &                        GRID(ng)%vmask,                           &
#   endif
     &                        vbarBgErr)
#   endif

!
!  Get the depth-component for transport calculations.
!
          CALL extract_obs2d (ng, 0, Lm(ng)+1, 0, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj,                       &
     &                        ObsState2Type(isTransport2d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng), uXmax(ng),                     &
     &                        uYmin(ng), uYmax(ng),                     &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend)+0.5_r8,                  &
     &                        PathY(Rstr:Rend),                         &
     &                        GRID(ng)%h,                               &
#   ifdef MASKING
     &                        GRID(ng)%rmask,                           &
#   endif
     &                        path_h)

# ifdef DISTRIBUTE
!
!  Collect the vectors from the tiles
!
          Ncollect=Robs
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_time)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_h)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_ubar)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_vbar)
#  ifndef IS4DVAR_SENSITIVITY
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_vetting)
#  endif
#  ifdef BGQC
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, ubarBgErr)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, vbarBgErr)
#  endif
# endif
!
!  Compute NLM transport in the master thread after the fields are
!  collected.
!
          IF (Master) THEN
            Aobs(iobs)=IniVal
            ObsVetting(iobs)=0.0_r8
            DO ic=1,Robs
              IF (path_vetting(ic).ne.0.0_r8) THEN
                Aobs(iobs)=Aobs(iobs)+                                  &
     &                     PathLength(Rstr-1+ic)*path_h(ic)*Sv*         &           
     &                     (path_ubar(ic)*SIN(PathAngle(Rstr-1+ic))+    &
     &                      path_vbar(ic)*COS(PathAngle(Rstr-1+ic)))
              END IF
            END DO
#   ifdef BGQC
            BgErr(iobs)=MAX(MAXVAL(ubarBgErr), MAXVAL(vbarBgErr))
#   endif
            IF (Aobs(iobs).ne.0.0_r8) THEN
              ObsVetting(iobs)=1.0_r8
            END IF
          END IF
!
!  Free the allocated arrays
!
          IF (allocated(path_time)) THEN
            deallocate (path_time)
          END IF

          IF (allocated(path_type)) THEN
            deallocate (path_type)
          END IF

          IF (allocated(path_vetting)) THEN
            deallocate (path_vetting)
          END IF

          IF (allocated(path_ubar)) THEN
            deallocate (path_ubar)
          END IF

          IF (allocated(path_vbar)) THEN
            deallocate (path_vbar)
          END IF

          IF (allocated(path_h)) THEN
            deallocate (path_h)
          END IF

# ifdef BGQC
          IF (allocated(ubarBgErr)) THEN
            deallocate (ubarBgErr)
          END IF

          IF (allocated(vbarBgErr)) THEN
            deallocate (vbarBgErr)
          END IF
# endif
        END IF OBS_TYPE
      END DO OBS_THREAD
      END SUBROUTINE extract_transport_2d

# ifdef SOLVE3D
!
!***********************************************************************
      SUBROUTINE extract_transport_3d (ng, Imin, Imax, Jmin, Jmax,      &
     &                          LBi, UBi, LBj, UBj, LBk, UBk,           &
     &                          ifield, Mstr, Mend, Nout,               &
     &                          Xmin, Xmax, Ymin, Ymax, Aobs)
!***********************************************************************
!
      USE mod_fourdvar
      USE mod_grid
      USE mod_ncparam
      USE mod_ocean
      USE mod_parallel
      USE mod_scalars
# ifdef DISTRIBUTE
      USE distribute_mod,  ONLY :  mp_collect
# endif
      USE extract_obs_mod, ONLY : extract_obs3d
!
!  Imported variable declarations.
!
      integer, intent(in) :: ng, Imin, Imax, Jmin, Jmax
      integer, intent(in) :: LBi, UBi, LBj, UBj, LBk, UBk
      integer, intent(in) :: ifield, Mstr, Mend, Nout
!
      real(r8), intent(in) :: Xmin, Xmax, Ymin, Ymax
!
#  ifdef ASSUMED_SHAPE
      real(r8), intent(inout) :: Aobs(:)
#  else
      real(r8), intent(inout) :: Aobs(Mobs)
#  endif
!
!  Local variable declarations.
!
      integer :: ic, iobs, Rstr, Rend
      real(dp) :: TimeLB, TimeUB

      real(r8), parameter :: IniVal = 0.0_r8, Sv = 1.0e-6_r8

      integer, allocatable, dimension(:) :: path_type
      real(r8), allocatable, dimension(:) :: path_time
      real(r8), allocatable, dimension(:) :: path_vetting, path_hz
      real(r8), allocatable, dimension(:) :: path_u, path_v
      real(r8) :: transport
#  ifdef BGQC
      real(r8), allocatable, dimension(:) :: uBgErr, vBgErr
#  endif

!
!  Find the transport path observations that are available
!  for the current time.
!
      TimeLB=(time(ng)-0.5_dp*dt(ng))/86400.0_dp
      TimeUB=(time(ng)+0.5_dp*dt(ng))/86400.0_dp

      OBS_THREAD : DO iobs=Mstr,Mend
        OBS_TYPE : IF ((ObsType(iobs).eq.                               &
     &                  ObsState2Type(isTransport2d)).and.              &
     &      ((TimeLB.le.Tobs(iobs)).and.(Tobs(iobs).lt.TimeUB))) THEN

!
!  Find the transport path points for this transport observation
!
          Rend=0
          Rstr=99999999
          DO ic=1,Npath(ng)
            IF (PathID(ic).eq.ObsMeta(iobs)) THEN
              Rstr=MIN(Rstr,ic)
              Rend=MAX(Rend,ic)
            END IF
          END DO
          Robs=Rend-Rstr+1
          IF (Rstr.gt.Rend) THEN
            ObsVetting(iobs)=0.0_r8
            CYCLE
          END IF

!
!  Allocate the arrays of the transport path data
!
          allocate ( path_time(Robs) )
          path_time=Tobs(iobs)

          allocate ( path_type(Robs) )
          path_type=ObsState2Type(isTransport3d)

          allocate ( path_vetting(Robs) )
          path_vetting=IniVal

          allocate ( path_u(Robs) )
          path_u=IniVal

          allocate ( path_v(Robs) )
          path_v=IniVal

          allocate ( path_hz(Robs) )
          path_hz=IniVal

#  ifdef BGQC
          allocate ( uBgErr(Robs) )
          uBgErr=IniVal

          allocate ( vBgErr(Robs) )
          vBgErr_hz=IniVal
#  endif

!
!  Get the u-component for transport calculations.
!
          DO k=1,N(ng)
            DO j=Jstr-1,Jend+1
              DO i=IstrU-1,Iend+1
                GRID(ng)%z_v(i,j,k)=0.5_r8*(GRID(ng)%z_r(i-1,j,k)+      &
     &                                      GRID(ng)%z_r(i  ,j,k))
              END DO
            END DO
          END DO
          CALL extract_obs3d (ng, 1, Lm(ng)+1, 0, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj, 1, N(ng),             &
     &                        ObsState2Type(isTransport3d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng)+0.5_r8,                         &
     &                        uXmax(ng)+0.5_r8,                         &
     &                        uYmin(ng), uYmax(ng),                     &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend)+0.5_r8,                  &
     &                        PathY(Rstr:Rend), PathZ(Rstr:Rend),       &
     &                        OCEAN(ng)%u(:,:,:,Nout),                  &
     &                        GRID(ng)%z_v,                             &
#   ifdef MASKING
     &                        GRID(ng)%umask,                           &
#   endif
     &                        path_u)
#   ifdef BGQC
          CALL extract_obs3d (ng, 1, Lm(ng)+1, 0, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj, 1, N(ng),             &
     &                        ObsState2Type(isTransport3d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng)+0.5_r8, rXmax(ng)+0.5_r8,       &
     &                        uYmin(ng), uYmax(ng),                     &
     &                        time(ng), dt(ng),                         &
     &                        path_type, path_vetting,                  &
     &                        path_time, PathX(Rstr:Rend)+0.5_r8,       &
     &                        PathY(Rstr:Rend), PathZ(Rstr:Rend),       &
     &                        OCEAN(ng)%e_u(:,:,:,1),                   &
     &                        GRID(ng)%z_v,                             &
#    ifdef MASKING
     &                          GRID(ng)%umask,                         &
#    endif
     &                          uBgErr)
#   endif

!
!  Get the v-component for transport calculations.
!
          DO k=1,N(ng)
            DO j=Jstr-1,Jend+1
              DO i=IstrU-1,Iend+1
                GRID(ng)%z_v(i,j,k)=0.5_r8*(GRID(ng)%z_r(i-1,j,k)+      &
     &                                      GRID(ng)%z_r(i  ,j,k))
              END DO
            END DO
          END DO
          CALL extract_obs3d (ng, 0, Lm(ng)+1, 1, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj, 1, N(ng),             &
     &                        ObsState2Type(isTransport3d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng), uXmax(ng),                     &
     &                        uYmin(ng)+0.5_r8,                         &
     &                        uYmax(ng)+0.5_r8,                         &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend),                         &
     &                        PathY(Rstr:Rend)+0.5_r8,                  &
     &                        PathZ(Rstr:Rend),                         &
     &                        OCEAN(ng)%v(:,:,:,Nout),                  &
     &                        GRID(ng)%z_v,                             &
#   ifdef MASKING
     &                        GRID(ng)%vmask,                           &
#   endif
     &                        path_v)
#   ifdef BGQC
          CALL extract_obs3d (ng, 0, Lm(ng)+1, 1, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj, 1, N(ng),             &
     &                        ObsState2Type(isTransport3d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng), uXmax(ng),                     &
     &                        uYmin(ng)+0.5_r8,                         &
     &                        uYmax(ng)+0.5_r8,                         &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend),                         &
     &                        PathY(Rstr:Rend)+0.5_r8,                  &
     &                        PathZ(Rstr:Rend),                         &
     &                        OCEAN(ng)%e_v(:,:,:,1),                   &
     &                        GRID(ng)%z_v,                             &
#   ifdef MASKING
     &                        GRID(ng)%vmask,                           &
#   endif
     &                        vBgErr)
#  endif

!
!  Get the thickness-component for transport calculations.
!
          CALL extract_obs3d (ng, 0, Lm(ng)+1, 0, Mm(ng)+1,             &
     &                        LBi, UBi, LBj, UBj, 1, N(ng),             &
     &                        ObsState2Type(isTransport3d),             &
     &                        Robs, 1, Robs,                            &
     &                        uXmin(ng), uXmax(ng),                     &
     &                        uYmin(ng), uYmax(ng),                     &
     &                        time(ng), dt(ng), path_type,              &
     &                        path_vetting, path_time,                  &
     &                        PathX(Rstr:Rend)+0.5_r8,                  &
     &                        PathY(Rstr:Rend), PathZ(Rstr:Rend),       &
     &                        GRID(ng)%Hz,                              &
     &                        GRID(ng)%z_r,                             &
#  ifdef MASKING
     &                        GRID(ng)%rmask,                           &
#  endif
     &                        path_hz)

#  ifdef DISTRIBUTE
!
!  Collect the vectors from the tiles
!
          Ncollect=Robs
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_hz)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_u)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_v)
#   ifndef IS4DVAR_SENSITIVITY
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, path_vetting)
#   endif
#   ifdef BGQC
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, uBgErr)
          CALL mp_collect (ng, iNLM, Ncollect, IniVal, vBgErr)
#   endif
#  endif
!
!  Compute NLM transport in the master thread after the fields are
!  collected.
!
          IF (Master) THEN
            Aobs(iobs)=IniVal
            ObsVetting(iobs)=0.0_r8
            DO ic=1,Robs
              IF (path_vetting(ic).ne.0.0_r8) THEN
                Aobs(iobs)=Aobs(iobs)+                                  &
     &                     PathLength(Rstr-1+ic)*path_hz(ic)*Sv*        &           
     &                     (path_u(ic)*SIN(PathAngle(Rstr-1+ic))+       &
     &                      path_v(ic)*COS(PathAngle(Rstr-1+ic)))
              END IF
            END DO
#  ifdef BGQC
            BgErr(iobs)=MAX(MAXVAL(uBgErr), MAXVAL(vBgErr))
#  endif
            IF (Aobs(iobs).ne.0.0_r8) THEN
              ObsVetting(iobs)=1.0_r8
            END IF
          END IF
!
!  Free the allocated arrays
!
          IF (allocated(path_time)) THEN
            deallocate (path_time)
          END IF

          IF (allocated(path_type)) THEN
            deallocate (path_type)
          END IF

          IF (allocated(path_vetting)) THEN
            deallocate (path_vetting)
          END IF

          IF (allocated(path_u)) THEN
            deallocate (path_u)
          END IF

          IF (allocated(path_v)) THEN
            deallocate (path_v)
          END IF

          IF (allocated(path_hz)) THEN
            deallocate (path_hz)
          END IF

#  ifdef BGQC
          IF (allocated(uBgErr)) THEN
            deallocate (uBgErr)
          END IF

          IF (allocated(vBgErr)) THEN
            deallocate (vBgErr)
          END IF
#  endif
        END IF OBS_TYPE
      END DO OBS_THREAD
      END SUBROUTINE extract_transport_3d
# endif
#endif
      END MODULE extract_transport_mod
